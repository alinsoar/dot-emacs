
(defun get-color-themes ()
  (get-files-from-directory themes-directory
                            ;; (directory-files (concat CONFIG-ROOT-DIR "/" themes-directory "/")
                            ;;                  nil)
                            "^[[:alnum:]].*"))

(defun set-color-theme (theme)
    (interactive
     (list
      (ido-completing-read
       "themes: "
       (get-color-themes))))
    (setq COLOR-THEME theme))

(defun get-files-from-directory (dir match &optional f)
  (let ((files (directory-files (format "%s/%s/" CONFIG-ROOT-DIR dir)
                                nil
                                match)))
    (if f (mapcar f files) files)))

(defun check-missing-modes ()
  (let* ((theme-defs
          (mapcar (lambda (x)
                    (cons x (get-files-from-directory
                             (concat themes-directory "/" x)
                             "^[[:alpha:]].*[.el]"
                             (lambda (x) (substring x 0 (- (length x) 3))))))
                  (get-color-themes)))
         (all-modes (apply 'append (mapcar 'cdr theme-defs))))
    (dolist (m all-modes)
      (dolist (tdef theme-defs)
        (let ((theme:name (car tdef))
              (theme:modes (cdr tdef)))
          (or (member m theme:modes)
              (message "missing %s from theme %s" m theme:name)))))))

(defun select-face (&rest l)
  (nth (random (length l)) l))

(defun load-theme-config-file-p ()
  (and
   (stringp COLOR-THEME)
   (cond ((member COLOR-THEME (get-color-themes)) ; for X
	  (is-x?))
	 ;; add themes for other systems ?
	 (nil))))

(defmacro op-named-color (op color x)
  `(let ((rgb (color-name-to-rgb ,color))
         r g b)
     (setq r (* 255 (nth 0 rgb))
           g (* 255 (nth 1 rgb))
           b (* 255 (nth 2 rgb)))
     (format "#%02x%02x%02x"
             (min 255 (,op r x))
             (min 255 (,op g x))
             (min 255 (,op b x) ) ) ))

(defun divide-color (col x) (op-named-color / col 2))
(defun multiply-color (col x) (op-named-color * col 2))

(defun chcol ()
  "convert themes generated by customize into theme syntax."
  (defun ch (a b)
    (goto-char 1)
    (while (re-search-forward a nil t) (replace-match b nil nil)))
  (ch ":family" ":FM")
  (ch ":background" ":BG")
  (ch ":foreground" ":FG")
  (ch ":box" ":BX")
  (ch ":height" ":H")
  (ch ":underline" ":U")
  (ch ":strike-through" ":ST")
  (ch ":overline" ":O")
  (ch ":weight" ":W")
  (ch ":slant" ":SL")
  (ch ":inherit" ":I")
  (ch ":style" "::S")
  (ch ":color" "::C")
  (ch " default" " :I default"))

(defun theme-faces-abbrev-expand (attrib)  
  (let ((abbrevs
         '(
           (::C . :color)
           (::S . :style)
           (:BG . :background)
           (:BX . :box)
           (:E  . :extend)
           (:FG . :foreground)
           (:FM . :family)
           (:FO . :foundry)
           (:H  . :height)
           (:IV . :inverse-video)
           (:O  . :overline)
           (:SL . :slant)
           (:ST . :strike-through)
           (:T  . :stipple)
           (:U  . :underline)
           (:W  . :weight)
           )))
    (or (alist-get attrib abbrevs)
        (error "unknown face attriute: %s" attrib))))

(defun get-face-value (val)
  (cond
   ((and (listp val) (keywordp (car val)))
    (get-face-attributes val))
   ((listp val) (eval val))
   (t val)))

(defun get-face-attributes (a)
  (cond ((null a) nil)
        ((eq (car a) :I)
         (display-warning '(:I/include) "do not use :I" :warning "*Messages*")
         (setq inherit (list (cadr a)))
         (get-face-attributes (cddr a)))
        (t (cons (theme-faces-abbrev-expand (car a))
                 (cons (get-face-value (cadr a))
                       (get-face-attributes (cddr a)))))))

(defun rewrite-face-attributes (f-a*)
  ;; f-a* looks like: (mode-line :FG "orange red" :U "green" :H 110)
  ;; result looks like: (mode-line :foreground "orange red" :underline "green" :height 110)
  (let ((a* (get-face-attributes (cdr f-a*)))
        (face/name (car f-a*)))
    (cons face/name
     (if a*
         (append (list a*) inherit)
       inherit))))

(defun make-faces-list (faces)
  (cond ((null faces) '())
        ((eq (caar faces) :INCLUDE)
         ;; see for example Magit theme
         (let* ((included-from (file-name-directory (cadar faces)))
                (from-file (symbol-name (caddar faces)))
                (dir/file (concat included-from "/" from-file)))
           (make-faces-list
            (append
             (read
              (format
               "(%s)"
               (with-temp-buffer
                 (insert-file-contents-literally dir/file)
                 (buffer-substring-no-properties
                  (point-min)
                  (point-max)))))
             (cdr faces)))))
        (t
         (cons (car faces)
               (make-faces-list (cdr faces))))))

(defun expand-faces (f*)
  (mapcar
   (lambda (x)
     (setq inherit nil)
     (rewrite-face-attributes x))
   (make-faces-list f*)))

(defmacro global-face (face &rest f*)
  (list 'quote
        `(,face . (,(expand-faces
                     `((,t . ,f*)))))))

(global-face tab-bar :FM "Monaco" :BG "red")

(defmacro define-theme-faces (&rest faces)
  ;;; face-remapping-alist MUST be buffer-local here.
  `(s!
    face-remapping-alist
    (expand-faces ',faces)))

(defmacro add-faces-to-theme (&rest faces)
  `(dolist (a (expand-faces ',faces))
     (apply 'face-remap-add-relative a)))

;;; ~~ ~~ ~~ define file colors for DIRED mode ~~ ~~ ~~

;;; The NAME.EXTENSION and COLUMN delimiters are common for all themes
(defconst fileinfo-entries
  (concat ".*"                         ; junk
          "[[:digit:] ][[:digit:]]"    ; <hourHH> or <space yearY>
          "[[:digit:]:]"               ; <:> or <yearY>
          "[[:digit:]][[:digit:]]"))
(defconst fileinfo-data
  (concat "............"
          "[ ]+\\([[:digit:]]*\\)[ ]" ; hardlinks
          "\\([^ ]+\\)[ ]+"           ; user
          "\\([^ ]+\\)[ ]+"           ; group
          "\\([[:digit:]]*\\)[ ]"     ; size
          "\\([[:alpha:].]+\\)[ ]+"   ; month
          "\\([[:digit:]]+\\)[ ]+"    ; day
          "\\([[:digit:]:]+\\)[ ]"    ; hour/year
          ))

(defmacro make-filename-colors (fileinfo
                                basename-regex
                                extension-regex
                                &rest indexes)
  "FILEINFO is one of the constants FILEINFO-ENTRIES or FILEINFO-DATA"
  `(s! dired-font-lock-keywords
       ;; dired-internal faces have priority, in head of the list
       (append dired-font-lock-keywords
               `(( ,(concat "^"
                            ,fileinfo          ; OUTPUT OF LS
                            ,basename-regex    ; BASENAME
                            ,extension-regex   ; EXTENSION
                            "$")
                   .                    ; this is CONS
                   ,(mapcar
                     (lambda (x)
                       (list (car x)
                             `',(intern
                                 (concat "dired-"
                                         (symbol-name (cadr x))))))
                     '(,@indexes)))))))

(defmacro dired-make-single-face (type face/attr &optional x)
  (let ((face/name (intern (format "dired-%s%s" type (or x "")))))
    (if (memq face/name (face-list))
        (let ((attrs (mapcar 'car (face-all-attributes face/name))))
          '(message "FACE %s already defined" face/name)
          (dolist (a attrs)
            (set-face-attribute face/name nil a 'unspecified))
          `(add-faces-to-theme ,(cons face/name face/attr)))
      `(prog1
           '(message "DEFFACE %s" ',face/name)
         (defface ,face/name '((t nil ))
           ,(format ".%s file type in dired" type))
         (add-faces-to-theme ,(cons face/name face/attr))))))

(defmacro dired-make-faces (type face-name face-ext)
  `(prog1 ,(format "define face for %s in dired" type)
     (dired-make-single-face ,type ,face-name "-name")
     (dired-make-single-face ,type ,face-ext "-ext") ) )

(defun dired/mk/ext/match (ext*)
  (concat (seq-reduce (lambda (a x)
                        (concat  a "\\|" x))
                      (cdr ext*)
                      (concat "[.]\\(" (car ext*)))
          "\\)"))

(defmacro dired-file-split-faces (face &rest ext)
  `(make-filename-colors fileinfo-entries
                         "[ ]\\(.*\\)"
                         ,(dired/mk/ext/match ext)
                         (1 ,(intern (format "%s-name" face)))
                         (2 ,(intern (format "%s-ext" face)))))

;;; ~~ ~~ ~~ 

